#!/usr/libexec/ui/cscript
version 1.1;
/*
********************************************************
This script is an op script that displays a troubleshooting summary of the most relevant information,
it's operational status and the status of major protocols and interfaces.
It's set up in modular way so that you can add/remove a template using call functions in the match /
Feel free to email me with questions or comments.
********************************************************
To run this script it must be installed in /var/db/scripts/op/ and called junos-sys-checks.slax 
The following configuration must be present:            
 `set system scripts op file junos-sys-checks.slax`   
Then Type: `op junos-sys-checks` to run it                
********************************************************
*/

ns junos = "http://xml.juniper.net/junos/*/junos";
ns xnm = "http://xml.juniper.net/xnm/1.1/xnm";
ns jcs = "http://xml.juniper.net/junos/commit-scripts/1.0";

ns func extension = "http://exslt.org/functions";
ns ztp = "http://xml.juniper.net/junos/ztp";
ns exsl extension = "http://exslt.org/common";

import "../import/junos.xsl";

var $SYSLOG = "external.warning";
var $TARGET-VERSIONS := {
    <device> {
        <model-name> "ex2200";
        <target-version> "12.3R12.4";
    }
    <device> {
        <model-name> "ex2300";
        <target-version> "21.4R3-S3.4";
    }
    <device> {
        <model-name> "srx220";
        <target-version> "12.3X48-D105.4";
    }
    <device> {
        <model-name> "srx320";
        <target-version> "21.4R3-S3.4";
    }
}
/* Collect defined mode from cli or set default mode to base for ZTP operations [full|base|proto|conn] */
param $mode = "base";
/* Collect snap option from cli or set default mode to enable snapshots to be performce [yes|no] */
param $snap = "yes";

match /
{
    var $jnx = jcs:open();
    mvar $message = "";

    /* Get serial number on current device */
    var $serial = ztp:serial-number( $jnx );
    var $SYSLOG_TAG = " " _ $serial _ " - ";

    var $get_config = <get-configuration database="committed" inherit="inherit">;
    var $configuration = jcs:invoke($get_config);

    <op-script-results>  {
            expr jcs:output("-------------------------------------------------------------------------------------------------------");
            set $message = "                      Welcome "_ $user _ "                         Mode: "_ $mode;
            call send_message($SYSLOG_TAG, $message);
            expr jcs:output("-------------------------------------------------------------------------------------------------------");
            set $message = "         ** This is the output of the sys_check script for "_ $serial _" on " _ $product _ " ** ";
            call send_message($SYSLOG_TAG, $message);
            expr jcs:output("-------------------------------------------------------------------------------------------------------");
        if (($mode == "full") || ($mode == "base")) {
            call chassis_template($SYSLOG_TAG);
            expr jcs:output("-------------------------------------------------------------------------------------------------------");
            call system_template($SYSLOG_TAG);
            expr jcs:output("-------------------------------------------------------------------------------------------------------");
        }
        if (($mode == "full") || ($mode == "proto")) {
            call ospf_template($SYSLOG_TAG, $configuration);
            expr jcs:output("-------------------------------------------------------------------------------------------------------");
            call mpls_template($SYSLOG_TAG, $configuration);
            expr jcs:output("-------------------------------------------------------------------------------------------------------");
            call bgp_template($SYSLOG_TAG, $configuration);
            expr jcs:output("-------------------------------------------------------------------------------------------------------");
        }
        if (($mode == "full") || ($mode == "conn")) {
            if (starts-with($product,"srx")) {
                call vpn_template($SYSLOG_TAG);
                expr jcs:output("-------------------------------------------------------------------------------------------------------");
            }
            call interface_template($SYSLOG_TAG, $configuration);
            expr jcs:output("-------------------------------------------------------------------------------------------------------");
        }
    }
}

template chassis_template($SYSLOG_TAG) {
    mvar $message = "";
    mvar $quality_test = "PASS";

    /* CHASSIS ALARMS */

    var $query_chassis-alarms = { <command> "show chassis alarms"; }
    var $result_chassis-alarms = jcs:invoke($query_chassis-alarms);
    <alarm-information> {
        for-each($result_chassis-alarms/alarm-detail) {
            if (alarm-class == "Minor") {
                set $message = "CHASSIS:   **  WARN  ** : " _ alarm-class _" ALARM - " _ alarm-description;
                call send_message($SYSLOG_TAG, $message);
            }
            else if (alarm-class == "Major") {
                set $message = "CHASSIS:   *** FAIL *** : " _ alarm-class _" ALARM - " _ alarm-description;
                call send_message($SYSLOG_TAG, $message);
            }
            else {
                set $message = "CHASSIS:   !!! ERROR !! : Active alarm was not captured by script";
                call send_message($SYSLOG_TAG, $message);
            }
        }
        if ($result_chassis-alarms/alarm-summary/no-active-alarms) {
            set $message = "CHASSIS:   **  PASS  ** : There are no active chassis alarms";
            call send_message($SYSLOG_TAG, $message);
        }
    }

    /* CHASSIS HARDWARE STATUS */

    var $query_environment_information = { <get-environment-information>; }
    var $environment_information = jcs:invoke($query_environment_information);
    set $quality_test = "PASS";
    for-each ($environment_information/environment-item[status!="OK"]) {
        set $message = "CHASSIS:   *** FAIL *** : Component - " _ name _ " is " _ status;
        call send_message($SYSLOG_TAG, $message);
        if (comment) {
            set $message = "                          Details: " _ comment;
            call send_message($SYSLOG_TAG, $message);
        }
        if (temperature) {
            set $message = "                          Temperature: " _ temperature;
            call send_message($SYSLOG_TAG, $message);
        }
        set $quality_test = "FAIL";
    }
    if ($quality_test == "PASS") {
        set $message = "CHASSIS:   **  PASS  ** : Environment component checks are all OK";
        call send_message($SYSLOG_TAG, $message);
    }

    /* CHASSIS PIC INFORMATION */

    var $query_pic_information = { <get-pic-information>; }
    var $pic_information = jcs:invoke($query_pic_information);
    set $quality_test = "PASS";
    for-each ($pic_information/fpc) {
        if (state!="Online") {
            set $message = "CHASSIS:   *** FAIL *** : FPC - " _ slot _ " is " _ state;
            call send_message($SYSLOG_TAG, $message);
            set $quality_test = "FAIL";
        }
        for-each (/pic[pic-state!="Online"]) {
            set $message = "CHASSIS:   *** FAIL *** : PIC - " _ pic-slot _ " on FPC - " _ slot _ " is " _ state;
            call send_message($SYSLOG_TAG, $message);
            if (pic-type) {
                set $message = "                          Component: " _ description;
                call send_message($SYSLOG_TAG, $message);
            }
            set $quality_test = "FAIL";
        }
    }
    if ($quality_test == "PASS") {
        set $message = "CHASSIS:   **  PASS  ** : FPC and PIC status checks are all OK";
        call send_message($SYSLOG_TAG, $message);
    }

    /* POE CONTROLLER FIRMWARE CHECK */

    var $query_poe_information = { <get-poe-controller-information>; }
    var $poe_information = jcs:invoke($query_poe_information);
    set $quality_test = "PASS";
    for-each ($poe_information/controller-information) {
        if (controller-firmware-available) {
            set $message = "CHASSIS:   **  FAIL  ** : POE Controller " _ controller-number _ " requires update!";
            call send_message($SYSLOG_TAG, $message);

            set $message = "CHASSIS:   *   INFO   * : Run `request system firmware upgrade poe fpc-slot " _ controller-number _ "`";
            call send_message($SYSLOG_TAG, $message);
            set $message = "CHASSIS:   *   INFO   * : This procedure is disruptive and will take around 10 mins to complete...";
            call send_message($SYSLOG_TAG, $message);
            set $message = "CHASSIS:   *   INFO   * : Run `show poe controller` to confirm completion";
            call send_message($SYSLOG_TAG, $message);

            /* ### Future feature to enable auto POE Update on request ###
            if ($POE_UPDATE == "yes") {
                var $command3 = jcs:invoke(<command> "request system firmware upgrade poe fpc-slot " _ controller-number);
                if ($command3) {
                    expr jcs:output($command3);
                    set $message = "CHASSIS:   **  WARN  ** : POE Controller " _ controller-number _ " update triggered!";
                    call send-message($SYSLOG_TAG, $message);
                    set $message = "CHASSIS:   **  WARN  ** : This procedure will take around 10 minutes to complete...";
                    call send-message($SYSLOG_TAG, $message);
                    set $message = "CHASSIS:   **  WARN  ** : Run `show poe controller` to confirm completion";
                    call send-message($SYSLOG_TAG, $message);
                }
                else {
                    set $test3 = "FAIL";
                }
            }
            else {
                set $test3 = "FAIL";
            }
            */
        }
        else {
            set $message = "CHASSIS:   **  PASS  ** : POE Controller " _ controller-number _ " is up-to-date!";
            call send_message($SYSLOG_TAG, $message);
        }
    }
    if ($quality_test == "FAIL") {
        set $message = "CHASSIS:   **  FAIL  ** : POE Controller Firmware update failed or was not performed.";
        call send_message($SYSLOG_TAG, $message);
    }
}

template system_template($SYSLOG_TAG) {
    mvar $message = "";
    mvar $quality_test = "PASS";

    /* SYSTEM ALARMS */

    var $query_system_alarms = { <command> "show system alarms"; }
    var $system_alarms = jcs:invoke($query_system_alarms);
    <alarm-information> {
        for-each($system_alarms/alarm-detail) {
            if (alarm-class == "Minor") {
                set $message = "SYSTEM:    **  WARN  ** : " _ alarm-class _" ALARM - " _ alarm-description;
                call send_message($SYSLOG_TAG, $message);
            }
            else if (alarm-class == "Major") {
                set $message = "SYSTEM:    *** FAIL *** : " _ alarm-class _" ALARM - " _ alarm-description;
                call send_message($SYSLOG_TAG, $message);
            }
            else {
                set $message = "SYSTEM:    !!! ERROR !! : Active alarm was not captured by script";
                call send_message($SYSLOG_TAG, $message);
            }
        }
        if ($system_alarms/alarm-summary/no-active-alarms) {
            set $message = "SYSTEM:    **  PASS  ** : There are no active system alarms";
            call send_message($SYSLOG_TAG, $message);
        }
    }

    /* SYSTEM UPTIME AND USERS */

    var $query_system_users = { <command> "show system users"; }
    var $system_users = jcs:invoke($query_system_users);
    if ($system_users/multi-routing-engine-item) {
        for-each ($system_users/multi-routing-engine-item) {
            set $message = "SYSTEM:    *   INFO   * : System (" _ re-name _ ") Uptime is " _ system-users-information/uptime-information/up-time;
            call send_message($SYSLOG_TAG, $message);
            for-each (./system-users-information/uptime-information/user-table/user-entry) {
                set $message = "SYSTEM:    *   INFO   * : " _ user _" is currently logged in from " _ from _" since " _ login-time;
                call send_message($SYSLOG_TAG, $message);
            }
        }
    }
    else {
        <system-users-information> {
            set $message = "SYSTEM:    *   INFO   * : System Uptime is " _$system_users/uptime-information/up-time;
            call send_message($SYSLOG_TAG, $message);
            for-each ($system_users/uptime-information/user-table/user-entry) {
                set $message = "SYSTEM:    *   INFO   * : " _ user _" is currently logged in from " _ from _" since " _ login-time;
                call send_message($SYSLOG_TAG, $message);
            }
        }
    }

    /* SYSTEM LAST COMMIT */

    var $query_system_commits = { <command> "show system commit"; }
    var $system_commits = jcs:invoke($query_system_commits);
    <commit-information> {
        set $message = "SYSTEM:    *   INFO   * : Last commit was " _$system_commits/commit-history/date-time _" by: " _$system_commits/commit-history/user;
        call send_message($SYSLOG_TAG, $message);
    }

    /* SYSTEM VERSION */

    var $query_software_information = { <get-software-information> {<detail>;}; }
    var $software_information = jcs:invoke($query_software_information);
    mvar $current-version-number = "";
    mvar $target-version-number = "";

    /** GET CURRENT VERSION **/

    if ($software_information/multi-routing-engine-item) {
        for-each ($software_information/multi-routing-engine-item) {
            for-each (//version-information[component= "RPD"]) {
                set $current-version-number = release;
            }
            set $message = "SYSTEM:    *   INFO   * : Device is a " _ //product-model _ " running " _ $current-version-number;
            call send_message($SYSLOG_TAG, $message);
        }
    }
    else {
        for-each ($software_information//version-information[component= "RPD"]) {
            set $current-version-number = release;
        }
        set $message = "SYSTEM:    *   INFO   * : Device is a " _ $product _ " running " _ $current-version-number;
        call send_message($SYSLOG_TAG, $message);
    }

    /** GET TARGET VERSION **/

    for-each ($TARGET-VERSIONS/device) {
        if ( starts-with($product, model-name )) {
            set $target-version-number = target-version;
        }
    }

    /** COMPARE CURRENT VERSION TO TARGET VERSION **/

    if( $target-version-number == "" ) {
        set $message = "SYSTEM:    !!! ERROR !! : No target version defined!";
        call send_message($SYSLOG_TAG, $message);
    }
    else if( $current-version-number != $target-version-number ) {
        set $message = "SYSTEM:    *** FAIL *** : Device " _ $product _ " is not running target Version of Junos, (" _ $target-version-number _ ")";
        call send_message($SYSLOG_TAG, $message);
    }
    else if( $current-version-number == $target-version-number ) {
        set $message = "SYSTEM:    **  PASS  ** : Device is running the target software release";
        call send_message($SYSLOG_TAG, $message);
    }

    /* ROUTING-ENGINE-STATUS */

    var $query_re_information = { <get-route-engine-information>; }
    var $route_engine_information = jcs:invoke($query_re_information);

    for-each ($route_engine_information/route-engine) {
        if ((mastership-state!="master") && (mastership-state!="backup")) {
            set $message = "SYSTEM:    *** FAIL *** : RE" _ slot _ " is not OK";
            call send_message($SYSLOG_TAG, $message);
        }
        if ((slot=="0") && (status=="OK")) {
            set $message = "SYSTEM:    *   INFO   * : RE0 is " _ status _ " and " _ mastership-state;
            call send_message($SYSLOG_TAG, $message);
        }
        if ((slot=="1") && (status=="OK")) {
            set $message = "SYSTEM:    *   INFO   * : RE1 is " _ status _ " and " _ mastership-state;
            call send_message($SYSLOG_TAG, $message);
        }
        if ((!slot) && (status=="OK")) {
            set $message = "SYSTEM:    **  PASS  ** : Routing Engine is " _ status;
            call send_message($SYSLOG_TAG, $message);
        }
        if (cpu-temperature>="65") {
            set $message = "SYSTEM:    **  WARN  ** : System temperature high!!! ("_ cpu-temperature _").";
            call send_message($SYSLOG_TAG, $message);
        } else {
            set $message = "SYSTEM:    **  PASS  ** : System temperature is normal!";
            call send_message($SYSLOG_TAG, $message);
        }
        if ((cpu-idle<="50") || (load-average-fifteen>=0.75)) {
            set $message = "SYSTEM:    **  WARN  ** : System load is high!!! (User: "_ cpu-user _"% System: "_ cpu-system _"% Background: "_ cpu-background _"%)";
            call send_message($SYSLOG_TAG, $message);
        }
    }

    /* SYSTEM STORAGE CHECK */

    var $query_system_storage = { <command> "show system storage"; }
    var $system_storage_information = jcs:invoke($query_system_storage);
    var $filesystem_regex = "\/dev\/(gpt\/junos|(da|bo)0s([12]a|3[ef]))";
    set $quality_test = "PASS";
    if ($system_storage_information/multi-routing-engine-item) {
        for-each ($system_storage_information/multi-routing-engine-item) {
            for-each (./system-storage-information/filesystem[filesystem-name=='/dev/gpt/junos']) {
                if (./used-percent >= 90) {
                    set $message = "SYSTEM:    *** FAIL *** : Disk Partition " _ mounted-on _ " on " _ ../../re-name _" is currently at " _ used-percent _ "% used space.";
                    call send_message($SYSLOG_TAG, $message);
                    set $quality_test = "FAIL";
                }
                else if (./used-percent >= 75) {
                    set $message = "SYSTEM:    **  WARN  ** : Disk Partition " _ mounted-on _ " on " _ ../../re-name _" is currently at " _ used-percent _ "% used space.";
                    call send_message($SYSLOG_TAG, $message);
                    set $quality_test = "WARN";
                }
            }
        }
    }
    else {
        <system-storage-information> {
            for-each ($system_storage_information/filesystem[filesystem-name==jcs:regex($filesystem_regex,filesystem-name)]) {
                if (./used-percent >= 90) {
                    set $message = "SYSTEM:    *** FAIL *** : Disk Partition " _ mounted-on _ " is currently at " _ used-percent _ "% used space.";
                    call send_message($SYSLOG_TAG, $message);
                    set $quality_test = "FAIL";
                }
                else if (./used-percent >= 75) {
                    set $message = "SYSTEM:    **  WARN  ** : Disk Partition " _ mounted-on _ " is currently at " _ used-percent _ "% used space.";
                    call send_message($SYSLOG_TAG, $message);
                    set $quality_test = "WARN";
                }
            }
        }
    }
    if ($quality_test=="PASS") {
        set $message = "SYSTEM:    *   PASS   * : All tested disk partitions are below 75% Used.";
        call send_message($SYSLOG_TAG, $message);
    }

    /* SYSTEM SNAPSHOT CHECK */

    mvar $snapshot_check_result_1 = "";
    mvar $snapshot_check_result_2 = "";
    if (starts-with($product, "ex2")) {
        var $snapshot_version_1 = ztp:show-snapshot-version($product);
        if ($snapshot_version_1 != "") {
            set $message = "SYSTEM:    *   INFO   * : Device is detected as EX Switch, current snapshot version is "_ $snapshot_version_1;
            call send_message($SYSLOG_TAG, $message);
            if (starts-with($snapshot_version_1, $current-version-number)) {
                set $snapshot_check_result_1 = "MATCH";
                set $message = "SYSTEM:    **  PASS  ** : System Snapshot matchs current Junos version (" _ $current-version-number _ ")";
                call send_message($SYSLOG_TAG, $message);
            }
            else {
                set $snapshot_check_result_1 = "NOMATCH";
                set $message = "SYSTEM:    **  WARN  ** : System Snapshot does NOT match current Junos version (" _ $current-version-number _ ")";
                call send_message($SYSLOG_TAG, $message);
            }
        }
        else {
            set $message = "SYSTEM:    !!! ERROR !! : Snapshot information could not be found.";
            call send_message($SYSLOG_TAG, $message);
        }
        if (($snapshot_check_result_1 != "MATCH") && ($snap == "yes")) {
            set $message = "SYSTEM:    *   INFO   * : Attempting to perform system snapshot...";
            call send_message($SYSLOG_TAG, $message);
            if (ztp:take-snapshot($product)) {
                set $message = "SYSTEM:    *   INFO   * : System Snapshot taken... Should now match current Junos version - checking!";
            }
            else {
                set $message = "SYSTEM:    *** FAIL *** : System Snapshot failed... Checking snapshots...";
            }
            call send_message($SYSLOG_TAG, $message);
        
            var $snapshot_version_2 = ztp:show-snapshot-version($product);
            if ($snapshot_version_2 != "") {
                set $message = "SYSTEM:    *   INFO   * : Current snapshot version is now "_ $snapshot_version_2;
                call send_message($SYSLOG_TAG, $message);
                if (starts-with($snapshot_version_2, $current-version-number)) {
                    set $snapshot_check_result_2 = "MATCH";
                    set $message = "SYSTEM:    **  PASS  ** : System Snapshot matchs current Junos version (" _ $current-version-number _ ")";
                    call send_message($SYSLOG_TAG, $message);
                }
                else {
                    set $snapshot_check_result_2 = "NOMATCH";
                    set $message = "SYSTEM:    *** FAIL *** : System Snapshot failed and does NOT match current Junos version (" _ $current-version-number _ ")";
                    call send_message($SYSLOG_TAG, $message);
                }
            }
            else {
                set $message = "SYSTEM:    !!! ERROR !! : Snapshot information could not be found.";
                call send_message($SYSLOG_TAG, $message);
            }
        }
    }
    else if ((starts-with($product, "srx")) || (starts-with($product, "ex")))  {
        var $show_snapshot_information_1 = ztp:show-snapshot-version($product);
        <snapshot-information> {
            if ($show_snapshot_information_1/software-version/package/package-version) {
                set $message = "SYSTEM:    *   INFO   * : Checking system snapshots... wait...";
                call send_message($SYSLOG_TAG, $message);
                for-each ($show_snapshot_information_1/software-version) {
                    if (!starts-with(package/package-version, $current-version-number)) {
                        set $snapshot_check_result_1 = "NOMATCH";
                        set $message = "SYSTEM:    **  WARN  ** : System Snapshot does NOT match current Junos version (" _ package/package-version _ ")";
                        call send_message($SYSLOG_TAG, $message);
                        if ($snap == "yes") {
                            set $message = "SYSTEM:    *   INFO   * : Performing System Snapshot... wait...";
                            call send_message($SYSLOG_TAG, $message);
                            /* TODO: This reports as failed on SRXs but actually succeeds... */
                            if (ztp:take-snapshot($product)) {
                                set $message = "SYSTEM:    *   INFO   * : System Snapshot taken... Should now match current Junos version - checking...";
                            }
                            else {
                                set $message = "SYSTEM:    *** FAIL *** : System Snapshot failed!!!";
                            }
                            call send_message($SYSLOG_TAG, $message);
                        }
                    }
                }
                if ($snapshot_check_result_1 == "") {
                    set $message = "SYSTEM:    **  PASS  ** : System Snapshots match current Junos version (" _ $show_snapshot_information_1/software-version/package/package-version _ ")";
                    call send_message($SYSLOG_TAG, $message);
                    set $snapshot_check_result_1 = "MATCH";
                }
            }
            else {
                set $message = "SYSTEM:    !!! ERROR !! : System Snapshot could not be determined or does not exist.";
                call send_message($SYSLOG_TAG, $message);
            }
        }
        if (($snapshot_check_result_1 != "MATCH") && ($snap == "yes")) {
            var $show_snapshot_information_2 = ztp:show-snapshot-version($product);
            <snapshot-information> {
                if ($show_snapshot_information_2/software-version/package/package-version) {
                    set $message = "SYSTEM:    *   INFO   * : Checking system snapshots (Post-Snapshot)... wait...";
                    call send_message($SYSLOG_TAG, $message);
                    for-each ($show_snapshot_information_2/software-version) {
                        if (!starts-with(package/package-version, $current-version-number)) {
                            set $snapshot_check_result_2 = "NOMATCH";
                            set $message = "SYSTEM:    *** FAIL *** : System Snapshot does NOT match the current Junos version after snapshot operation.";
                            call send_message($SYSLOG_TAG, $message);
                        }
                    }
                    if ($snapshot_check_result_2 == "") {
                        set $message = "SYSTEM:    **  PASS  ** : System Snapshot now matches current Junos version (" _ $show_snapshot_information_2/software-version/package/package-version _ ")";
                        call send_message($SYSLOG_TAG, $message);
                        set $snapshot_check_result_2 = "MATCH";
                    }
                }
                else {
                    set $message = "SYSTEM:    !!! ERROR !! : System Snapshot could not be determined or does not exist.";
                    call send_message($SYSLOG_TAG, $message);
                }
            }
        }
    }
    else {
        set $message = "SYSTEM:    !!! ERROR !! : Device type not EX or SRX, snapshot check aborted.";
        call send_message($SYSLOG_TAG, $message);
    }

    /* LICENSE CHECK */

    var $query_license_summary = {
        <get-license-summary-information>;
    }
    var $license_summary = jcs:invoke($query_license_summary);
    for-each ($license_summary/license-usage-summary/feature-summary) {
        if (validity-type=="invalid") {
            set $message = "SYSTEM:    *** FAIL *** : The feature license " _ name _ " is " _ validity-type;
            call send_message($SYSLOG_TAG, $message);
        }
        if (used-licensed>licensed) {
            set $message = "SYSTEM:    *** FAIL *** : The feature license " _ name _ " is oversubscribed!";
            call send_message($SYSLOG_TAG, $message);
        }
    }
}

template ospf_template($SYSLOG_TAG, $configuration) {
    mvar $message = "";

    /* OSPF-CONFIG-CHECK */

    if (!$configuration/protocols/ospf) {
        set $message = "OSPF:      *   INFO   * : OSPF is not configured";
        call send_message($SYSLOG_TAG, $message);
    }
    else {
        /* OSPF-NEIGHBORS-UP-COUNT */

        var $query_ospf_neighbours = {
            <get-ospf-neighbor-information>;
        }
        var $ospf_neighbours = jcs:invoke($query_ospf_neighbours);
        var $ospf_neighbour_count = count($ospf_neighbours/ospf-neighbor[ospf-neighbor-state=="Full"]) + count($ospf_neighbours/ospf-neighbor[ospf-neighbor-state=="2Way"]);
        mvar $msg_sev = "*   INFO   *";
        if ($ospf_neighbour_count == "0") { set $msg_sev = "**  WARN  **"; }
        set $message = "OSPF:      "_$msg_sev _" : There are "_$ospf_neighbour_count _ " OSPF neighbor sessions UP";
        call send_message($SYSLOG_TAG, $message);

        /* OSPF-NEIGHBOR-DOWN-IDENTIFICATION */

        for-each($ospf_neighbours/ospf-neighbor) {
            if ((ospf-neighbor-state=="Exchange") || (ospf-neighbor-state=="ExStart")) {
                set $message = "OSPF:      **  WARN  ** : Neighbour, "_ neighbor-address _" on "_ interface-name _ " has stalled, may be MTU issue";
                call send_message($SYSLOG_TAG, $message);
            }
        }

        var $query_ospf_interfaces = { <command> "show ospf interface detail"; }
        var $ospf_interfaces = jcs:invoke($query_ospf_interfaces);
        <ospf-interface-information> {
            for-each($ospf_interfaces/ospf-interface) {
                if (ospf-interface-state=="Down") {
                    set $message = "OSPF:      *** FAIL *** : OSPF member interface, " _ interface-name _" is DOWN";
                    call send_message($SYSLOG_TAG, $message);
                }
                if ((neighbor-count=="0") && (interface-name!="lo0.0") && (!ospf-interface-topology/ospf-topology-passive)) {
                    set $message = "OSPF:      **  WARN  ** : Interface " _ interface-name _" has no OSPF sessions";
                    call send_message($SYSLOG_TAG, $message);
                }
            }
        }
    }
}

template mpls_template($SYSLOG_TAG, $configuration) {
    mvar $message = "";

    /* MPLS-CHECK */
    if (!$configuration/protocols/mpls) {
        set $message = "MPLS:      *   INFO   * : MPLS is not configured";
        call send_message($SYSLOG_TAG, $message);
    }
    else {        
        var $query_mpls_int_information = {
            <get-mpls-interface-information>;
        }
        var $mpls_int_information = jcs:invoke($query_mpls_int_information);
        
        /* MPLS-INTERFACE-UP-COUNT */

        var $mpls_int_count = count($mpls_int_information/mpls-interface[mpls-interface-state="Up"]);
        mvar $msg_sev = "*   INFO   *";
        if ($mpls_int_count == "0") { set $msg_sev = "**  WARN  **"; }
        set $message = "MPLS:      "_$msg_sev _" : There are "_$mpls_int_count _ " MPLS interfaces UP";
        call send_message($SYSLOG_TAG, $message);

        /* MPLS-INTERFACES-DOWN */

        for-each ($mpls_int_information/mpls-interface[mpls-interface-state!="Up"]) {
            set $message = "MPLS:      *** FAIL *** : Interface "_ interface-name _ " is " _ mpls-interface-state;
            call send_message($SYSLOG_TAG, $message);
        }

        call ldp_template($SYSLOG_TAG, $configuration);
        
        call rsvp_template($SYSLOG_TAG, $configuration);
    }
}

template ldp_template($SYSLOG_TAG, $configuration) {
    mvar $message = "";

    /* LDP-CHECK */

    if (!$configuration/protocols/ldp) {
        set $message = "LDP:       *   INFO   * : LDP is not configured";
        call send_message($SYSLOG_TAG, $message);
    }
    else { 
        var $query_ldp_int_information = {
            <get-ldp-interface-information>;
        }
        var $ldp_int_information = jcs:invoke($query_ldp_int_information);

        /* LDP-NEIGHBORS-UP-COUNT */
    
        var $ldp_int_count = count($ldp_int_information/ldp-interface[ldp-neighbor-count=="1"]);
        mvar $msg_sev = "*   INFO   *";
        if ($ldp_int_count == "0") { set $msg_sev = "**  WARN  **"; }
        set $message = "LDP:       "_$msg_sev _" : There are " _$ldp_int_count _ " LDP neighbor interfaces UP (inc lo0.0)"; 
        call send_message($SYSLOG_TAG, $message);

        /* LDP-SESSION-UP-COUNT */

        var $query_ldp_sessions = {
            <get-ldp-session-information>;
        }
        var $ldp_sessions = jcs:invoke($query_ldp_sessions);
        var $ldp_session_count = count($ldp_sessions/ldp-session[ldp-session-state=="Operational"]);
        set $msg_sev = "*   INFO   *";
        if ($ldp_session_count == "0") { set $msg_sev = "**  WARN  **"; }
        set $message = "LDP:       "_$msg_sev _" : There are "_$ldp_session_count _ " neighbor sessions UP";
        call send_message($SYSLOG_TAG, $message);

        /* LDP-NEIGHBOR-DOWN-IDENTIFICATION */

        for-each($ldp_int_information/ldp-interface) {
            if (ldp-neighbor-count=="0") {
                set $message = "LDP:       *** FAIL *** : Interface " _ interface-name _" has zero neighbors";
                call send_message($SYSLOG_TAG, $message);
            }
        }
    }
}

template rsvp_template($SYSLOG_TAG, $configuration) {
    mvar $message = "";

    /* RSVP-CHECK- */

    if (!$configuration/protocols/rsvp) {
        set $message = "RSVP:      *   INFO   * : RSVP is not configured";
        call send_message($SYSLOG_TAG, $message);
    }
    else{
        var $query_rsvp_int_information = {
            <get-rsvp-interface-information>;
        }
        var $rsvp_int_information = jcs:invoke($query_rsvp_int_information);
    
        /* RSVP-NEIGHBORS-UP-COUNT */

        var $rsvp_int_count = count($rsvp_int_information/rsvp-interface[rsvp-status="Up"]);
        mvar $msg_sev = "*   INFO   *";
        if ($rsvp_int_count == "0") { set $msg_sev = "**  WARN  **"; }
        set $message = "RSVP:      "_$msg_sev _" : There are "_$rsvp_int_count _ " RSVP interfaces UP";
        call send_message($SYSLOG_TAG, $message);

        /* RSVP-LSP's */

        var $query_mpls_lsps = {
            <get-mpls-lsp-information>;
        }
        var $mpls_lsps = jcs:invoke($query_mpls_lsps);
        for-each ($mpls_lsps/rsvp-session-data[session-type=="Ingress"]) {
            set $message = "RSVP:      *   INFO   * : There are " _ count _ " Egress-LSPs Operational";
            call send_message($SYSLOG_TAG, $message);
        }
        for-each ($mpls_lsps/rsvp-session-data[session-type=="Egress"]) {
            set $message = "RSVP:      *   INFO   * : There are " _ count _ " Ingress-LSPs Operational";
            call send_message($SYSLOG_TAG, $message);
        }

        /* RSVP-NEIGHBOR-DOWN-IDENTIFICATION */

        for-each($rsvp_int_information/rsvp-interface) {
            if ((rsvp-status=="Down") && (interface-name!="lo0.0")) {
                set $message = "RSVP:      *** FAIL *** : Neighbor session configured on " _ interface-name _" is DOWN";
                call send_message($SYSLOG_TAG, $message);
            }
        }
    }
}

template bgp_template($SYSLOG_TAG, $configuration) {
    mvar $message = "";

    /* BGP-CHECK */

    if (!$configuration/protocols/bgp) {
        set $message = "BGP:       *   INFO   * : BGP is not configured";
        call send_message($SYSLOG_TAG, $message);
    }
    else {
        var $query_bgp_summary = {
            <get-bgp-summary-information>;
        }
        var $bgp_summary = jcs:invoke($query_bgp_summary);
        
        /* BGP-NEIGHBORS-UP-COUNT */

        var $bgp_peer_count = count($bgp_summary/bgp-peer[peer-state=="Established"]);
        mvar $msg_sev = "*   INFO   *";
        if ($bgp_peer_count == "0") { set $msg_sev = "**  WARN  **"; }
        set $message = "BGP:       "_$msg_sev _" : There are "_$bgp_peer_count _ " BGP neighbor sessions UP";
        call send_message($SYSLOG_TAG, $message);

        /* BGP-NEIGHBOR-DOWN-IDENTIFICATION */

        for-each($bgp_summary/bgp-peer[peer-state!="Established"]) {
            set $message = "BGP:       *** FAIL *** : Peer " _ description _" @ " _ peer-address _" is DOWN";
            call send_message($SYSLOG_TAG, $message);
        }
    }
}

template vpn_template($SYSLOG_TAG) {
    mvar $message = "";

    /* VPN-TUNNEL-UP-COUNT */

    var $query_security_assoc = {
        <get-security-associations-information>;
    }
    var $security_assoc = jcs:invoke($query_security_assoc);
    <ipsec-security-associations-information> {
        if($security_assoc/total-active-tunnels != 0) {
            set $message = "VPN:       *   INFO   * : There are "_ total-active-tunnels _ " VPN tunnels UP";
            call send_message($SYSLOG_TAG, $message);
        }
    }

    /* VPN-TUNNEL-DOWN-IDENTIFICATION */

    var $query_inactive_tunnels = {
        <get-inactive-tunnels>;
    }
    var $query_inactive_tunnel_details = {
        <get-inactive-tunnels> {
            <detail>;
        }
    }
    var $inactive_tunnels = jcs:invoke($query_inactive_tunnels);
    var $inactive_tunnel_details = jcs:invoke($query_inactive_tunnel_details);
    <ipsec-unestablished-tunnel-information> {
        if($inactive_tunnels/total-inactive-tunnels != 0) {
            for-each($inactive_tunnel_details/ipsec-security-associations-block) {
                set $message = "VPN:       *** FAIL *** : Tunnel " _ sa-vpn-name _" @ " _ sa-remote-gateway _" is DOWN";
                call send_message($SYSLOG_TAG, $message);
                set $message = "                          Reason: " _ sa-ipsec-tunnel-events/sa-tunnel-event;
                call send_message($SYSLOG_TAG, $message);
            }
        }
    }
    if ($message == "") { 
        set $message = "VPN:       *   INFO   * : There are no VPN tunnels Detected";
        call send_message($SYSLOG_TAG, $message);
    }
}

template interface_template($SYSLOG_TAG, $configuration) {
    mvar $message = "";
    mvar $quality_test = "PASS";

    /* CONFIGURED INTERFACES IN UP/DOWN STATE */

    for-each($configuration/interfaces/interface) {
        var $interface_name = name;
        var $query_interface_information = {
            <get-interface-information> {
                <terse>;
                if ($interface_name) {
                    <interface-name> $interface_name;
                }
            }
        }
        var $interface_information = jcs:invoke($query_interface_information);
        var $sev_text = (starts-with($product,"ex")) ? "**  WARN  **" : "*** FAIL ***"; 
        <interface-information> {
            for-each ($interface_information/physical-interface/logical-interface[admin-status=="up"][oper-status=="down"]) {
                set $message = "INTERFACE: "_ $sev_text _" : Configured interface " _ name _" is Admin Up but Operationally DOWN";
                call send_message($SYSLOG_TAG, $message);
                set $quality_test = "FAIL";
            }
        }
    }
    if ($quality_test=="PASS") {
        set $message = "INTERFACE: *   PASS   * : All Configured interfaces appear to be UP";
        call send_message($SYSLOG_TAG, $message);
    }

    /* CHECK CONFIGURED INTERFACES FOR ERRORS */

    for-each($configuration/interfaces/interface) {
        mvar $show_last_flap = false();
        var $interface_name = name;
        var $query_interface_detail = {
            <get-interface-information> {
                <extensive>;
                if ($interface_name) {
                    <interface-name> $interface_name;
                }
            }
        }
        var $interface_detail = jcs:invoke($query_interface_detail)/physical-interface;
        <interface-information> {
            var $test_list := {
                /* 
                    Table for listing the tests to be performed on an an individual XML path (not group of elements)
                    <check_name> = Name used to describe the test and print out on report prepended to the collected values
                    <path_name> = XML Path of the element you wish to test (cannot take wildcards)
                    <severity> = "FAIL" | "WARN" , "INFO" is the default if not specified, will display on report, with ** _ ** format...
                            "FAIL" also triggers action to change quality_test value if the test criteria is met.
                    <ignore-if-linkdown> = add to trigger a test skip if the interface is already in downstate.
                */
                <check> {
                    <check_name> "Link Mode is ";
                    <path_name> $interface_detail/link-mode;
                    <pass_value> "Full-duplex";
                    <severity> "WARN";
                    <ignore-if-linkdown>;
                }
                <check> {
                    <check_name> "Ethernet-Switching Errors: ";
                    <path_name> $interface_detail/eth-switch-error;
                    <pass_value> "none";
                    <severity> "FAIL";
                }
                <check> {
                    <check_name> "BPDU Errors: ";
                    <path_name> $interface_detail/bpdu-error;
                    <pass_value> "none";
                    <severity> "FAIL";
                }
                <check> {
                    <check_name> "Loop Detect PDU Errors: ";
                    <path_name> $interface_detail/ld-pdu-error;
                    <pass_value> "none";
                    <severity> "FAIL";
                }
                <check> {
                    <check_name> "Layer 2 Protocol Tunneling Errors: ";
                    <path_name> $interface_detail/l2pt-error;
                    <pass_value> "none";
                    <severity> "FAIL";
                }
                <check> {
                    <check_name> "Loopback is ";
                    <path_name> $interface_detail/loopback;
                    <pass_value> "disabled";
                    <severity> "WARN";
                }
                <check> {
                    <check_name> "Remote Fault: ";
                    <path_name> $interface_detail/if-remote-fault;
                    <pass_value> "online";
                    <severity> "FAIL";
                }
            }
            for-each ($test_list/check) {
                var $sev_text = (severity=="FAIL") ? "*** FAIL ***" : ((severity=="WARN") ? "**  WARN  **" : "*   INFO   *");
                if (($interface_detail/oper-status == "down") && (ignore-if-linkdown)) {
                    /* Skip this test */
                }
                else if ((path_name != "") && (path_name != pass_value)) {
                    set $message = "INTERFACE: " _ $sev_text _ " : Interface " _ $interface_detail/name _ " " _ check_name _ path_name;
                    call send_message($SYSLOG_TAG, $message);
                    if (severity == "FAIL") { 
                        set $quality_test = "FAIL"; 
                        set $show_last_flap = true();
                    }
                }
            }
            /* Autonegotion, if enabled check if completed else report state */
            if ($interface_detail/if-auto-negotiation == "enabled") {
                if ($interface_detail/ethernet-autonegotiation/autonegotiation-status == "complete") {
                    if ($interface_detail/ethernet-autonegotiation/link-partner-status == "OK") {
                        /* AutoNeg OK, skip reporting */
                    }
                    else { 
                        set $message = "INTERFACE: **  WARN  ** : Interface " _ $interface_detail/name _ " link Partner "_ $interface_detail/ethernet-autonegotiation/link-partner-status;
                        call send_message($SYSLOG_TAG, $message);
                        set $show_last_flap = true();
                    }
                }
                else {
                    set $message = "INTERFACE: **  WARN  ** : Interface " _ $interface_detail/name _ " autonegotiation "_ $interface_detail/ethernet-autonegotiation/autonegotiation-status;
                    call send_message($SYSLOG_TAG, $message);
                    set $show_last_flap = true();
                }
            } 
             /* Report on active alarms */
            if (!$interface_detail/active-alarms/interface-alarms/alarm-not-present) {
                for-each ($interface_detail/active-alarms/interface-alarms/*) {
                    set $message = "INTERFACE: **  WARN  ** : Interface " _ $interface_detail/name _ " has Active Alarms ("_ name() _")";
                    call send_message($SYSLOG_TAG, $message);
                    set $show_last_flap = true();
                }
            }
            /* Report on active Defects */
            if (!$interface_detail/active-defects/interface-alarms/alarm-not-present) {
                for-each ($interface_detail/active-defects/interface-alarms/*) {
                    set $message = "INTERFACE: **  WARN  ** : Interface " _ $interface_detail/name _ " has Active Defects ("_ name() _")";
                    call send_message($SYSLOG_TAG, $message);
                    set $show_last_flap = true();
                }
            }
            /* If requested by the previous tests show "last flapped" timestamp */
            if ($show_last_flap) {
                set $message = "INTERFACE: *   INFO   * : Interface " _ $interface_detail/name _ " last changed: " _ $interface_detail/interface-flapped;
                call send_message($SYSLOG_TAG, $message);
            }
            /* Check for input errors */
            for-each ($interface_detail/input-error-list/*[text() > 50]) {
                set $message = "INTERFACE: **  WARN  ** : Interface " _ $interface_detail/name _ " Detected INPUT Errors ("_ name() _": "_ text() _")";
                call send_message($SYSLOG_TAG, $message);
            }
            /* Check for output errors */
            for-each ($interface_detail/output-error-list/*[text() > 50]) {
                set $message = "INTERFACE: **  WARN  ** : Interface " _ $interface_detail/name _ " Detected OUTPUT Errors ("_ name() _": "_ text() _")";
                call send_message($SYSLOG_TAG, $message);
            }
            /* Check PCS Errors */
            for-each ($interface_detail/ethernet-pcs-statistics/*[text() > 100]) {
                set $message = "INTERFACE: **  WARN  ** : Interface " _ $interface_detail/name _ " Detected PCS Errors ("_ name() _": "_ text() _")";
                call send_message($SYSLOG_TAG, $message);
            }
            /* Check MAC CRC and FIFO Errors */
            for-each ($interface_detail/ethernet-mac-statistics/*[contains(name(),"errors")][text() > 100]) {
                set $message = "INTERFACE: **  WARN  ** : Interface " _ $interface_detail/name _ " Detected Errors ("_ name() _": "_ text() _")";
                call send_message($SYSLOG_TAG, $message);
            }
            /* Check FEC Errors */
            if ($interface_detail/ethernet-fec-mode/enabled_fec_mode) {
                for-each ($interface_detail/ethernet-fec-statistics/*[text() > 100]) {
                    set $message = "INTERFACE: **  WARN  ** : Interface " _ $interface_detail/name _ " Detected FEC Errors ("_ name() _": "_ text() _")";
                    call send_message($SYSLOG_TAG, $message);
                }
            }
            /* Checks if drop count is high on each QoS queue */
            for-each ($interface_detail/queue-counters/queue[queue-counters-total-drop-packets > 1000]) {
                set $message = "INTERFACE: *** FAIL *** : Interface queue, drop count high for " _ forwarding-class-name;
                call send_message($SYSLOG_TAG, $message);
                set $quality_test = "FAIL";
            }
        }
    }
    if ($quality_test=="PASS") {
        set $message = "INTERFACE: *   PASS   * : All Configured interfaces PASS";
        call send_message($SYSLOG_TAG, $message);
    }
}

/******************** END OF TEMPLATE *********************/

/* ---------------------------------------- */
/* this function is used get serial number  */
/* ---------------------------------------- */
<func:function name="ztp:serial-number">
{
    param $jnx;

    var $cmd = <get-chassis-inventory>;
    var $sn = jcs:execute( $jnx, $cmd )//chassis/serial-number;

    <func:result select="$sn">;
}

/* ----------------------------------------------- */
/* this function is used to show system snapshots  */
/* ----------------------------------------------- */
<func:function name="ztp:show-snapshot-version">
{
    param $model;
    mvar $cmd = { <command> "show system snapshot media internal";}
    mvar $snapshot_version = "";
    mvar $return = false();

    if (starts-with($model, "ex2")) {
        var $output = jcs:invoke( $cmd )//multi-routing-engine-item/output;
        var $lines = jcs:break-lines($output);
        for $line ($lines) {
            if (starts-with($line,'Junos version')) {
                set $snapshot_version = substring-after($line, 'Junos version: ');
            }
        }
        set $return = $snapshot_version;
    }
    else if (starts-with($model, "srx")) {
        var $output = jcs:invoke( $cmd );
        set $return = $output;
    }
    else if (starts-with($model, "ex")) {
        /* var $output = jcs:invoke( $cmd )//software-version[1]/package[1]/package-version[1]; */
        var $output = jcs:invoke( $cmd )//multi-routing-engine-item/snapshot-information;
        set $return = $output;
    }
    else {
        expr jcs:output('ERROR: Device type not EX or SRX, snapshot check aborted!');
    }
    result $return;
}

/* ----------------------------------------------- */
/* this function is used to take system snapshots  */
/* ----------------------------------------------- */
<func:function name="ztp:take-snapshot">
{
    param $model;
    mvar $cmd = "";
    mvar $return = false();

    if (starts-with($model, "ex2")) {
        set $cmd = <command> "request system snapshot recovery all-members";
        var $result = jcs:invoke( $cmd )//multi-routing-engine-item/output;
        if ($result) { set $return = true(); } 
    }
    else if ((starts-with($model, "srx")) || (starts-with($model, "ex"))) {
        set $cmd = <command> "request system snapshot slice alternate";
        var $result = jcs:invoke( $cmd )//snapshot-information/snapshot-copy/destination-directory;
        if ($result) { set $return = true(); }
    }
    else {
        expr jcs:output('ERROR: Device type not EX or SRX, snapshot aborted!');
    }
    result $return;
}

/* ------------------------------------------------------------------ */
/* this function is used to send a custom message to syslog and stout */
/* ------------------------------------------------------------------ */
template send_message($SYSLOG_TAG, $message)
{
    expr jcs:output( $message );
    expr jcs:syslog( $SYSLOG, $SYSLOG_TAG, $message );
}
